# DOM*j*nate

DOMjnate is a Java library that allows you to manipulate the HTML DOM entirely from Java. It takes the standard JavaScript API for working with web pages and provides properly typed interfaces for using that API in a type-safe manner from Java. For example, the code below creates some text that says "Click me!" The text changes to say "Yay!" when it is clicked.

```
win.getDocument().getBody().setInnerHTML("<div>Click me!</div>");
Element div = win.getDocument().querySelector("div");
div.addEventListener("click", (evt) -> {
  div.setTextContent("Yay!");
  evt.preventDefault();
});
```

DOMjnate lets your write user interface code in HTML5 entirely in Java. It can be used in two ways:

* Your Java code can then be compiled to JavaScript and run in a browser
* A webview widget can be created from Java, and your Java calls to DOMjnate will manipulate the webview

The name comes from the DOM of HTML's Document Object Model, a J for Java, and the word "dominate" to represent the goal of using HTML5 for all Java user interface code.




## Comparison to Elemental 2

It is mainly intended as an alternative to [Elemental 2](https://github.com/google/elemental2). DOMjnate has different goals and use-cases than Elemental 2, resulting in a slightly different API. 

* Elemental 2 uses real Java classes to represent JavaScript types and Java fields to represent JavaScript properties. This allows for proper run-time type checking and a Java API that feels more like the native JavaScript. 
* DOMjnate uses only Java interfaces to represent JavaScript types and Java getter/setter methods to represent JavaScript properties. This makes it easier to mock the interfaces in test code and gives the API a more "Java" feel. Although run-time type-checking is less strict because of the use of interfaces, this extra flexibility makes DOMjnate usable in unusual situations like having multiple global scopes (e.g. if you use iframes). 
* DOMjnate is generated based on Microsoft's Typescript typing of the DOM API (with the intention of supplementing it WebIDL type information) while Elemental 2 is based on Google's Closure externs.

The main advantage of DOMjnate over Elemental 2 though, is that in many cases, you can run and debug your code entirely from within Java without recompiling everything to JavaScript first. 

DOMjnate is primarily intended to be used with the GWT compiler. This lets you write all your code in Java, and then translate all your Java code into JavaScript to run things in a browser. But DOMjnate is also able to interface with the JavaFX webview and wrap all the JavaScript objects in the webview, so that you can run your Java code as normal Java code in a Java debugger without translating it to JavaScript first. Although this interfacing is a little clunky, it can potentially accelerate your development cycles because you don't need to compile your code to JavaScript everytime you want to debug your user interface. The same Java code will run the same in both your Java debugger and in a browser.

## Building

DOMjnate was developed using Java 11 though it can probably also be compiled with Java 10 and possibly Java 9. It has been tested with JavaFX 11 and GWT 2.8.2. It uses [JsInterop](http://www.gwtproject.org/doc/latest/DevGuideCodingBasicsJsInterop.html) to describe its interfaces, so DOMjnate is likely compatible with [j2cl](https://github.com/google/j2cl) as well. 

Maven `pom.xml` build scripts are supplied for DOMjnate. To build DOMjnate, simply run 

```
mvn install
```
 
This will build three modules:

- *domjnate-base* is a compatibility layer that allows the DOMjnate API to be used from GWT or directly from Java. 
- *domjnate-api* contains the actual Java bindings for the HTML5 DOM API. 
- *domjnate-javafx* is the module that lets DOMjnate be used directly in Java to control a JavaFX webview.
 
After the modules have been built, you can grab the `.jar` files from the corresponding `target` directories and use them in your projects. If you are using Maven, you can also just add a Maven dependency on the modules in your projects.

### Generating the API

The DOMjnate API is generated by the separate [DOMjnate Generator](https://github.com/my2iu/DomjnateGenerator) program. 

## Using DOM*j*nate in GWT

To use DOMjnate in GWT, you must include the `domjnate-base` and `domjnate-api` libraries in your project. You also need to include `JsInterop` but that library is likely included by default in your project.

In your `gwt.xml` file, you also need to specify dependencies on the domjnate libraries by adding these lines:

```
<inherits name='domjnate-base'/>
<inherits name='domjnate-api'/>
```

Most of the DOMjnate APIs require you to have a reference to the JavaScript `window` object. DOMjnate, however, does not provide a means for getting access to that object though.

You can use JSNI to write some JavaScript code for getting a reference to that object. For example, the code below gets the Window reference in the GWT entry point and then proceeds to set-up the UI: 

```
import com.google.gwt.core.client.EntryPoint;
import com.user00.domjnate.api.Window;

public class Program implements EntryPoint
{
  public void onModuleLoad()
  {
     Window win = win();
     
     // Start using the DOMjnate API here
  }
  
  public static native Window win() /*-{
     return $wnd;
   }-*/;
}
```

Because you are working with JavaScript objects instead of Java objects, you may encounter some unexpected behavior:

- Your compiled GWT code may throw a NullPointerException when casting from one JavaScript type to another. This happens because GWT statically analyzes the Java types in your program and concludes that there are no Java types that can be cast that way, so GWT replaces the cast with a null pointer. With DOMjnate, you are working with JavaScript objects, and it *is* possible to cast any JavaScript object to any other type. To avoid this issue, you can use the command `com.user00.domjnate.util.Js.cast(obj, NewInterface.class)` to cast between unrelated JavaScript types.


## Using DOM*j*nate in Java

DOMjnate provides a library for working with the JavaFX webview, allowing you to create an HTML5 user interface in that webview entirely from Java. JavaFX is compatible with AWT/Swing and SWT, so you can also use DOMjnate with those UI frameworks as well.

To use DOMjnate in this way, you need to include the `domjnate-base`, `domjnate-api`, and `domjnate-javafx` libraries in your project. You also need to include JavaFX in your project, especially the `javafx-web` library which includes the JavaFX webview.

You can then create a window with a webview widget. If you are using pure JavaFX, the code would look something like this:

```
public class Program extends javafx.application.Application
{
  public void start(Stage stage) throws MalformedURLException {
    BorderPane border = new BorderPane();
    WebView webView = new WebView();
    border.setCenter(webView);
    Scene scene = new Scene(border);
    stage.setScene(scene);
    stage.show();

    WebEngine engine = webView.getEngine();
    engine.getLoadWorker().stateProperty().addListener((ov, oldState, newState) -> {
      if (newState == State.SUCCEEDED)
        onload(engine);
    });
    // Provide an initial .html file to load into the webview
    engine.load( new File("index.html").toURI().toURL().toExternalForm());
  }

  void onload(WebEngine engine)
  {
     // Page has loaded, and you can now safely
     // start setting up your UI here
  }

  public static void main(String[] args)
  {
    launch(args);
  }
}
```

You should refer to the JavaFX documentation to see how to use JavaFX to open a webview inside a Swing or SWT program.

Most of the DOMjnate APIs require you to have a reference to the JavaScript `window` object. You can get a reference to the Window object of a webview using

```
JSObject jsWin = (JSObject)engine.executeScript("window");
Window win = DomjnateFx.createJsBridgeGlobalsProxy(Window.class, jsWin);
```

The DOMjnate APIs provide a Java interface to the standard JavaScript DOM APIs. DOMjnate uses Java's proxy functionality to provide "wrapper" classes that wrap JavaScript objects in the webview. When you make method calls on the DOMjnate API, the calls are forwarded to the corresponding JavaScript object, and the results are translated back to Java and returned.  

For the most part, these APIs can be used like normal Java interfaces. But the fact that DOMjnate wraps JavaScript objects with Java proxy objects does lead to some unusual behavior.

<!-- TODO: Include diagram of wrapper objects -->

- DOMjnate does not check the real types of JavaScript objects. Any JavaScript object can be "wrapped" by DOMjnate so that it looks like it supports any interface regardless of whether that JavaScript object actually supports that interface or not.
- Since you are working with Java wrappers over JavaScript objects and not directly working with the real JavaScript objects themselves,  it's possible to have different wrappers for the same JavaScript object. This means that a JavaScript object might be represented in Java by different wrapper objects. If you compare those Java objects using `==`, it will claim that the objects are different, even though the wrapper objects still refer to the same underlying JavaScript object.
- Regardless of the underlying type of the JavaScript object, the only supported interfaces available in Java are those provided by the wrapper object. If you need to downcast a Java reference to a subtype, you often need a new wrapper object that exports the extra functionality of the underlying JavaScript object. To get a new wrapper object, you can use the command `com.user00.domjnate.util.Js.cast(obj, NewInterface.class)` command. This will return a new wrapper object for `obj` that supports the `NewInterface` interface. So, essentially, anywhere in Java where you would cast a DOMjnate object, such as `NewInterface newIntf = (NewInterface)obj;`, you should change it to `NewInterface newIntf = Js.cast(obj, NewInterface.class);`.
- The JavaFX webview is missing some functionality of a full browser. Even though DOMjnate provides methods and interfaces for most browser APIs, those APIs might not actually exist in the JavaFX webview.  

## Making programs that run in both GWT and from Java

Since DOMjnate can be used with both GWT and the JavaFX webview, you can use DOMjnate to write code that works in both. This is particularly useful during development. You can make use of the quicker development cycles and easier debugging tools of Java for development since debugging things in GWT can be cumbersome at times. If you need CSS or HTML inspectors, you can revert back to GWT. And you can use GWT to compile all your code to JavaScript for final deployment.

The entry points for a GWT program and a JavaFX program are different, so you would need different start-up classes for each version (they can coexist in the same project though). Once these entry points have finished setting up DOMjnate, they can then run code that is shared between the two versions. 

```
@GwtIncompatible
public class ProgramJavaFx extends Application
{
  public void start(Stage stage) throws MalformedURLException {
    BorderPane border = new BorderPane();
    WebView webView = new WebView();
    border.setCenter(webView);
    Scene scene = new Scene(border);
    stage.setScene(scene);
    stage.show();

    WebEngine engine = webView.getEngine();
    engine.getLoadWorker().stateProperty().addListener( (ov, oldState, newState) -> {
      if (newState == State.SUCCEEDED) {
        JSObject jsWin = (JSObject)engine.executeScript("window");
        Window win = DomjnateFx.createJsBridgeGlobalsProxy(Window.class, jsWin);
        ProgramShared.go(win);
      }});
    // Load the main GWT html page here
    engine.load(
        new File("index.html").toURI().toURL().toExternalForm());
  }

  public static void main(String[] args)
  {
    launch(args);
  }
}
```

```
public class ProgramGwt implements EntryPoint
{
  public void onModuleLoad()
  {
     Window win = win();
     ProgramShared.go(win);
  }
  
  public static native Window win() /*-{
     return $wnd;
   }-*/;
}
```

```
public class ProgramShared
{
  public static void go(Window win)
  {
    // Start your user interface
  }
}
```

When loading the initial web page from JavaFX, you have to be sure that it doesn't accidentally run any GWT-compiled JavaScript versions of your code because then you would have two versions of your code running at the same time. So either make sure that your GWT build scripts compile their JavaScript code to a different location than your base .html file, or delete the compiled GWT code each time you run your code from Java.


## Additional API Information

DOMjnate is currently under active development. Although basic functionality should work, some parts have not been tested and maybe unreliable or non-functional. The API may change at any time, and potentially quite drastically.  

Notably, DOMjnate will likely need to change package names in the future, its handling of generics needs to be redesigned, the system for handling callbacks may need to be redesigned, changes may be needed to properly support j2cl, different JS APIs may be spun off into separate packages, better typing of event handlers should be added, and the type information in the API should be augmented with information about integer types.  

Because of the way the DOMjnate API is designed, some aspects of the DOMjnate API don't feel like normal Java code or normal JavaScript code. In particular, DOMjnate uses interfaces to represent all JavaScript objects without providing any concrete implementations of those interfaces. Also, because DOMjnate supports multiple global scopes from either having multiple webview in Java or having multiple iframes in a webpage, many API methods require you to specify a `Window` object referring to the scope you want to use. In a normal web page, there is only one `window` object, so this will feel unusual to JavaScript programmers even though it is a situation that can occur in some more complex web pages.

Here are some additional notes about the DOMjnate API. 

### Constructors

Since all DOMjnate APIs are provided as interfaces, there is no direct way to instantiate them. Instead, a static `_new()` method is supplied that can be called to create a new instance of an object supporting that interface. This `_new()` method requires you to provide a `Window` object where DOMjnate can find the constructor for that type. 

### Static methods

When calling a DOMjnate static method, you also need to supply a `Window` object so that DOMjnate knows which context to call that static method in.

### Constants

Most JavaScript constants are standardized and well-defined, so they could have been embedded directly in the Java code. To be safe though, DOMjnate instead provides methods for reading out the constant value from JavaScript. Like a static method, programmers must supply a `Window` object so that DOMjnate knows which scope to read the constant from. To reduce verbiage, although constants are considered getters, the word `get` is not added to the front of the method names. 

### Function objects

Some API methods take a `Function` object as a parameter. To make a `Function` object from Java, you can take any interface with the `@JsFunction` annotation and then convert it to a JavaScript Function using the `com.user00.domjnate.util.Js.lambdaAsFunction()` method. Below is an example of how to use the method:

```
VoidFunction func = () -> { 
  // Code for lambda
}
Function jsFunc = (Function)Js.lambdaAsFunction(win, func);
```

### Performance

Because of the need to support manipulating a webview from within Java, DOMjnate does impose some slight overhead for certain operations, even when it is compiled to JavaScript using GWT.

Notably, calls to constructors are slow in JavaScript because of the need to create an intermediate function to do the creation. Certain static method calls will also be slower than expected. These slowdowns can potentially be avoided in the future using some simple optimizations in the GWT compiler.

When running the code in Java, there will be overhead involved every time objects are moved between Java and JavaScript. There is also some general sluggishness caused by running a webview under JavaFX. It is also unclear how garbage collection for the JavaFX webview works.
